## Hello! Welcome to my Nand2Tetris Project!

My project aims to follow along with the popular course Nand2Tetris by Noam Nisan and Shimon Schocken

Course link: [nand2tetris.org](https://www.nand2tetris.org)

This course provides a comprehensive understanding of computer science and operating systems by guiding students through the entire computational process, from simple binary signals to a functioning operating system. 

I decided to follow along with this course by using Python instead of the provided software becuase I believed that it would provide the best learning opportunity for me. While learning new concepts from the underlying material I also gained experience implementing solutions and troubleshooting problems that were unique to my situation. Had I just used the software provided I likely could have gotten a decent understanding but I think that I made the right choice in trying to do it in my own way. 

At the time of publishing this repo, I have completed the first section of the course, working all the way up to the creation of the assembler. I may return to complete the second step of the course in the future to implement the full operating system, but it may not be necessary for the information I wish to gain and may therefore focus my time on other subjects.  

The pureNAND folder in the project files was my first attempt at completing the course, only using a single if statement in the NAND file to determine what the bit outputs should be. Everything else in the folder is generated by combining this elementary gate into other combinatorial gates such as AND, OR, NOT, and a MUX/DMUX. I worked through the entire project until i reached the point of creating memory units, where I struggled for some time. It was at this point that I realized I needed something better than just using functions for everything because I could not implement thousands of memory registers only using global variables. I soon discovered how to use classes to store information which allowed me to continue on the course and start creating the CPU which would load memory units and manipulate data through the usage of an ALU.  

At this point, the limitation of the language I was using really began to set in because having python manually do gate operations on tens of thousands of bits was taking significant chunks of time for simple operations like reading an address from memory. This caused me to recreate all of the work I had already done by implementing list comprehensions into a memory module that would be significantly faster and allow me to actually continue with the course. 

I then had to work on actually loading data into the CPU, so I created a ROM unit that would read information from a .txt file, which need to be parsed properly. This called for an assembler to be able to take machine code instructions, complete with variables and comments, and turn it into binary instructions for the computer to read. I decided to just use dictionaries for the preset variables, so that I could replace whatever text was in the file with an address that would be generated at runtime based on the contents of the file. This allowed me to declare variables that would be assigned to a specific address and later referenced through jump instructions. Being able to define variables and jump instructions leads to the ability to make for loops and if statements, just like the programming language I was using to write the code itself. 

I believe this was a good stopping point, being that I had worked myself all the way from the most basic level of computing to essentially creating a functional, albeit low-level, programming language. Any further progess would be only related to the Nand2Tetris course and could not really be applied to real world operations. Even though there would be some information to gain, I believe that it would be better to focus my time on real world applications like learning C, or studying some UNIX operating system. 

I really enjoyed doing this project and it taught me a ton, can't wait to see what the future holds! 
